so welcome back for the third module of this week so in the last lecture we were talking about computational morphology ok so so in this module we will talk about how do we use financial math methods for doing this morphological analysis ok so i will just go in briefly into what these models do so starting with what is a finite state automaton ok so if you have taken a course on formal languages automaton theory or theory of computation you might already be aware of what is a finite automaton i will just briefly tell what is what what is this ok if you haven't taken a course that course you might just want to quickly see that in one of the ah one of the books for that course so what is a finite state automaton so it's kind of a directed graph ok so so in this in this figure you are seeing ah there is a finite automaton that is having six different nodes so these are the nodes here are called the states ok and there are edges between the nodes and they are the edges are labeled with certain symbols so for example you are seeing between node zero to one there is in there is an edge with a with the label of c ok and they may also be empty if for certain category of these automaton there are certain started states so for example here the node zero is the started state and there are certain accepting or final states that are noted by maybe ah having in having a double circles like on the node six you are having double circle this is an accepting state or the finite state so they can be more than one final state very easily so now what do the finite state automaton do so they are they they recognize a regular languages that is the language that is specified by the regular expressions so any regular expression you can always convert into a automaton financial automaton so now if you see the automaton that is provided on this slide what is the language that it at that it recognizes what are the words that will be passed through this and by seeing that you can also see how the automaton actually works so if you give an input like c o l o r to this automaton what will happen so it will start with the started state you will take the first character see from a started state on the input character see you will go to the state one from this graph now state one you take an input o that is the next in in the input and you move to state two and so on and as you end with the with the phoneme character r you end up with the state six in this graph so given an input like see c o l o r it is accepted by this automaton but what happens if i give a word like c o l o u r you can see the a path you can go from four to five and five to six and this automaton you can accept c o l u r so it will accept two words c o l o r c o l o u r but what happens if you give it is some other word like co l r so you will see c o l will go to state three but if you take r there is no path from three that takes an input r so it can't move further so this input will not be accepted by this automaton so what so given an automaton final state automaton what it does it it recognizes if a finite so not finite a regular language ok so if you give any string from the regular language it will accept that means this will end up in one of the accepting states but you should give it any other string that is not in the language it will not accept so this will not end up in any of the accepting states so now how are these finite state automaton used for doing the morphological analysis so what is the idea the idea is that when you when you combine various morphemes there are certain changes that happen at the boundary mainly concatenation and this is very very regular [ fina / phenomena ] so if or one want to capture that two words like boy and car can be made converted into plural by adding an s i can simply have a state for the noun where boy and car both come together and then i have a single single edge from there with s marking that there is a plural and now you think about all the possible plural that you can make in english all the singular nouns can come to the same state and then you have a single arrow that with s and that will convert into fluid so th so that very efficiently captures the process of converting in from singular to plural and as long as this is regular this is very very straightforward then how do you do that so here is an example in this slide so so only three states are shown here q naught q one q two q notice the starter state and q one and q two other accepting or finite states many other intermediate states are not shown we will see that in some of the later slides so from q naught to q one the regular nouns like car boy bag etcetera and then so all of these are also words in english you can now add a plural morpheme s to convert them into plural so go going from q one to q two but as such what happens if you have a irregular noun like goose to geese so that cannot go to q one because to goose if you apply as you will not get its plural form so for the irregular nouns you have a different path that goes from q naught that it to q two again there will be some intermediate nodes for individual characters of phonemes in in that in the language in the world so both the singular plural will go to q so q one and q two both will accept the words in the english similarly this is in f s a financial automaton for english adjectives ok so you have some prefix like un then you have the actual adjective root like happy and then certain suffixes like er e s t l y so you see here we are also showing some lot of morpho tactics that what kind of morphemes follow other kind of morphemes ok so now what kind of words that you can generate by using this automaton so you can say un happy unhappy ok a starting from q naught or from q naught you taking go to q one and you have happy and er happier happiest happily and so on ok so sick is generated words like happy happier happiest real from q naught you take an absolute transition go to q one then you have the adjective root real that can q two is a final state so you can generate real if you have generate unreal from q naught you take un that will give you un plus have the word real and go to q two you become you get unreal ok similarly all other words you can generate by using this particular automaton so yeah so as we already said in these examples we also seen some english morphotactics that is what kind of morphemes come after another kind of morphemes in in english no no but what do i do about regular in regular roots in english how do i capture that information in this automaton so can we include the lexicon also in my automaton so thats what we was see if i also want to include word like words like car cars bag everything in inside my automaton how do i do that so this is what we have seen so from q naught i take all the regular nouns to q one all the irregular nouns directly go to q two ok but now i want to include the lexicon so let's take a very very simple and a small lexicon so i have the words like bag boy and dog as the regular noun and man as the irregular noun and we want to generate all the so i want to recognize all the singular and plural form so what do i do so you see here from the state q naught i am now having all the possible other individual states that take the regular singular nouns to q one ok so i have different nodes for b and then the be shared among bag and boy ok similarly there is a different state for going to doc and finally all of these they go to q one all the regular nouns in the singular form and then you get you can have s added to that this becomes plural so you have dogs bags and boys together what do you do for the irregular nouns you have a different path man and m a n and m e n they again go to q two directly now given this figure can you recognize the words like boys easily yes i start with q naught when i get the word b i go to the next state o i go to another state why i go to q one and s i go to q two so i can recognize boys i can recognize boy m a n m e n all this can be recognized by this automaton i can further expand it to include other words my vocabulary ok but the education here is this the goal of morphological asks that we started with so what is this automaton doing given a word in english it will tell me whether it is a singular or plural word in english ok assuming that you have taken care of all the words in your vocabulary while building this automaton so it can recognize various words ok so so that's what we have written here so what are the properties of f s a s so so they are very very elegant ok so that is the recognition problem can be solved in linear time what do i mean by that given give give me any input string so you can find out whether automaton recognizes the string or not a linear time linear in the length of the string ok because every time you are making if you are having a word like boys you are checking if from the start state if you go if you take input b where do you go o y s and then finally if you end up in the accepted state you will accept the string otherwise you will not of course this will happen only for the deterministic automaton but as in the elegance of itself we know that every non deterministic finite automaton can be contributed to a deterministic finite automaton and there is in a simple algorithm for that so we do not have to worry about it even if we have started building an n f a i non deterministic automaton i can convert it to d f a where the linear time you can find out whether a string is accepted or not similarly i do not have to worry about getting the minimum mode of states of the automator ok because the again there is an algorithm that converts any automaton into it the equivalent automaton that has the minimum number of states ok so yeah so this is why we say this is very very elegant you can convert an n f a to d f a and in d f a you can convert in into the minimum number of st since very very elegant and we have seen that it can work as a language recognizer given a regular language it can can tell me a new given a new string whether this is in the language or not but so coming to my previous question is it what we need in the morphological analysis so answer is no this is not sufficient for the morphological analysis we so so take the word boys remember what are the different morphology analysis we talked about we talked about finding the lambdaization ok is like the simplest one lambdaization i want to find out what is the lemma for the word boys i want to find out the word boy can the d f a help me to obtain the word boy it it can't it can only tell me that boys is a word in my in my defined regular language this this is there so this is either single plural but it cannot tell whether boys is what is the lemma forward by so i need some some other more model that can give a word can also give me what is the lemma or the root form so for that so f s a s are language recognizer or generators so we need instead transducers that can help me do morphological analysis ok so what are transducers so transducers are very very similar to final state automaton except that they can help me translate one string into another ok so now what happens there how do they do that the model is very similar to f s a but now in each edge of the f s a instead of having a single phoneme as the label i have the input phoneme or input characters symbol and the output character symbol so it translates one character symbol to another character symbol so that that solves my problem of going from the input string like boys to an output this string like boy ok so let's take the example on the on on the on the same lexicon of forwards and they are plural so earlier we saw the final decision automaton where we were having each edge label within input character only so finally it could recognize whether a word is there in the language or not but now we have the transducer where each other is labeled with the input as well as the output character so you see here so here m m e n and e is the input a is the out so once you give an input like m e n to this transducer the output you will get is m e n the actual lemma ok that is how they can solve the morphological analysis problem now some small details that what might be the problem that that you might face while doing that so for example here is an input so we are calling it the lexical label cat i want to cat i want to convert it to a it's now but a plural form so i know cat cat gives me cats ok but what happens if i take a word like fox fox will give me foxes ok so there will be they are changed at the at the boundary you adding an e between fox and s so now there are many ways in which you can handle it one is you have you take cat has a regular know and then have a regular plural to that and fox as irregular noun separately this is one possibility but the interesting idea is if you can use a two level morphology that is between the lexical form cat plus non plus plural and the surface form that is cats can i define an intermediate form that is cat there is an s but in between there is some placeholder that can be null or e depending on what are the phonemes available in the stem and the surface so that is instead of going from lexical to surface level directly can i go to the individual level first this is my first label and then i transfer from intermediate label to the surface level in the second level of morphology so this is my two level morphologic so example is so the motivation example is for cats and foxs so instead of going from fox plus n plus p l two foxes i go to fox and some placeholder n n s and this is the end the now i can have a second label rule that says if my damaged fox of x is h s will there be some addition in the in between will there will be sudden change in between that can be taken care of by a separate module similarly cat there is a placeholder n s i can find out what should be the actual surface from given this intermediate form so here is an example so i have in my vocabulary words like fox cat goose ok and i am generating the singular and plural form so what are you seeing here from from fox to generate the plural form same with cat i add a placeholder as and the end of the character ok so so that is here now so this is my intermediate form so that means at this point i am not distinguishing between fox and cat they are behaving very very similarly so i need an additional process to find out given this intermediate form what should be the surface level form ok so so this is this is the two level morphology i go to fox s there is something in between that may be null or something else intermediate label and then from intermediate labeled you go to the surface level ok now what do you think the transition depend depends on from intermediate or surface label so it will depend on what are the ending characters of the stem and the starting director of the affix now given these what should be the replacement character ok so you can have these simple rules in this notation this is also called k notation for condensed context as sensitive rules ok so that so rules is that a letter a h converted to b if h visited by c and followed by d ok so this is if you remember the context sensitive grammar so that is what i am saying h converted to b if preceded by c and forward by d that means whenever a comes between c and d then you convert a to b ok this is the context sensitive rules so this kind of spelling change rules you can apply to go from intermediate label to the surface level you can use this rules to to do the conversion now so after talking about this two level morphology in general when people design the morphological analysis for the for a given language they follow two different kind of approaches ok so so they are also called the linguistic approach and engineering approach so what is the difference between the two ok so in the linguistic approach what will happen you have the stem stem is already defined in the in the in the lexicon or or the language and you have an affix that is also defined so to the stem you will apply the suffixes h but the surface changing rules will be taking care of separately by the rules of this kind that we have just seen so there will be rules of this kind that will define the the surface how what are the changes that are happening at the surface label on the other hand engineering approaches you won't have the separate rules for spelling changes they will try to find out the minimum possible unit of the stem that can be used and to that what other and the affixes can be big and in in that case that can be applied to the stem ok let's see one example that makes it clear so so the idea is that engineering approach all the phonetic irregularities will be factored into the endings so here is one example from check so so what you are seeing here so they are various words women owl draft iceberg wrapper and fly for each of these you have the actual word and so that is like for women z e n and or it's s o v so here the root word and there are various affixes are applied in various grammatical functions that are abstracted using s one s two s three so on and p two the various grammatical ah functions ok you might treat them as singular plural and and so on so to a given root word where is affixes have being applied so what you are seeing here are the final forms ok so for the initial two words they seen pretty pretty regular so you have the word s o v you apply a y e n o for getting different different forms similarly for z e n s k i c you see some difference right they are in red so what is the difference that you are seen so now the the suffix why has been changed to i in the case of h two similarly the accent is gone over e from me and you are getting the single sim simple e so that is why it's in red ok so this is a irregularity this is ok but what happens if we go to icework with k r you see in the case of s three even the stem that's a change so on are you are getting an accent and for p two you are getting another word another character e in between k r so you are getting k e r so now so so on you will see such changes even vapor and fly so now the question is how does one capture all this all the changes all these irregularities in the case of stems and the suffixes so now in the linguistic approach what will happen i will take the same route word so for example here i will have s k i c as the root word and k r as the root word and the same set of suffixes so y a y e with an accent you know are my suffixes that is my root and the suffix pair i will add these and whatever a spelling change rules i will try to enumerate whatever different spelling change rules by taking what is the previous character previous to previous character i will try to define the spelling changes in that way that is a linguistic approach what will happen in engineering approach i try to find out the part of the stem that is common across all all these variations so it's ok with the first three z e n s o v n s k i c but with k r i will take only k as common i will not take r because r is getting changed into something with an accent or with an e n r so i will take only k h common is part of my stem and everything else remaining i will convert into my stem that i might add and that you see in the last three so you have only k p n m as the actual strength and everything else goes into the suffix so this is what is engineering approach so by doing that you do not have to worry about handling the spelling change rules separately you are you handling them here itself ok so there are various tool kits set available for doing the morphological pricing for example at and t f s m library that is very popular again the open f s t tools is very very popular for doing the morphological analysis for a given language so so this is this was about our computation morphology using finite state methods so i have very very briefly talked about what our financial methods and how do we how do you use that for computational morphology so in the next lecture we will talk about in the same process a more popular problem about part of speech tagging so what is the problem part of speech tagging and what are the different computational models that you can use to handle that ok thank you