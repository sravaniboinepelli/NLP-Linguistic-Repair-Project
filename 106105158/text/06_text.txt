 ok so welcome back to the second week of this course so last week we handed with the with some the concept in pre processing of the text ok so so what are the concept that we covered we covered given is is sentence or document in general a text document how do i cyber into into a sentences how do a segment into words we saw what are the spec specific issues that might arise because of various languages and we talked about normalization case folding and other aspects like lamentation stability ok so these are some very very standard pre processing tasks that you might have to do on on a given text in in a given language ok but there is another task that you might have to do certain in in certain cases if the the data that you are obtaining is a bit noisy what i mean noisy there are certain spelling errors and you want to correct them for doing your ana analysis so this task is called spelling correction so what are the various ah problems that i involve in spelling correction and what are the different algorism that we will be using so we will be start with the very very simple algorithm of how do use at the distance for spelling correction in this particular lecture ok so what is the problem of start a spelling correction suppose you are you are reading or you are seeing the text in your data and the sentence is i am writing on behalf of but in behalf you see only b e h a f and the l is l is missing so now you want to correct this particular word to the actual word behalf now what is the auto what is the algorithm approach of of solving this problem ok so in general if you see this word like behalf so ideally we want want to find out what are the closest words in english that might come in place of this ok so what are the words you can think of i can think of probably behalf and i can think of probably behave yes and they might be some other words now so when i will talk we talking about spelling correction i will talk about two different scenarios one is isolated word error correction that is i am trying to correct a word that is incorrect but i am not trying to use the context around it so given the word b e h a f i want to correct it without choosing what is there before and after this word and this is call isolated word error detection so now so in this approach i will try to fin find the word that are closest to behalf ok you see maybe behalf and behave to will be two words now so immediately i have a i have a problem so how do i define what what is what do i mean by closest ok so ideally we say ok where you haven some sort of match between this word and that word but how do i further define it so i need some sort of distance metric how do i major distance between one word to another word and as per this metric whichever two words are coming out to be closer will be called as closest if there are coming to far i will not even consider that as a cand candidate for the correction so i really want a distance matter that that can give me the b e h a f and b e h a l l f are very very closed together so so we will start and we will actually use this the the metric called edit distance and this one of the simplest metric that we can think of in this case now what is edit distance ok so what is my problem i am given two strings ok in general i am given two strings one that is incorrect another might be correct and i have to find out what is the minimum distance between these two strings ok so ah so thats what i want to define by my concept of edit distance now how is defined so minimum edit distance is defined as the minimum number of edit operations that i have to do for going from one strings to another ok as a name say edit distance how many edits your making to go from one string to another string thats how it is defined now immediately i i will have the next question what are all the various edit operations i can make for going from one strings to another strings so we will start with three basic operations that are insertion that means i i insert a character in the first string deletion that means i i delete a character in the first string or substitution i delete or i substitute one charter in the first string by another one by another character so these are three different operations that we will considering so now my question would be how many of these operations are needed to go from one string to another string that is my edit distance between two strings ok so lets take a simple example so i have the initial word is intention and the final word is execution and i want to find out how many of these operations are required to go from intention to execution ok so now if i try try to see that so what is what am i doing to go from intention to execution i am first doing a deletion i deleted i ok now i substituted n with e again i substituted t with x i kept e as it is then i inserted c ok so here star means i went to null that is the deletion here null went to c that is insertion ok then again i did a substitution and with u and t i o n re remain as it is so how many operations i need i needed i needed five different operations one was deletion one insertion and three substitutions ok so here the various operations that i did now i need to define for these operations what will be the edit distance ok so there are two different variations that i can i can use in one variation i might say that each operation has cost of one so whether i am doing deletion insertion or substitution each has a cost of one so in this case what will be the edit distance between the two strings because i have done five operations each has a cost of one so distance will be five ok so this is called levenshtein distance now i may also use another variant where the substitution has a cost of two because this is one insertion and one deletion so if i takes substitution cost as two what will be the edit distance between the two strings so when i have one plus one for one insertion one deletion plus three times two four three substitutions that will be eight ok so now my question is that how go we find the minimum edit distance between two strings so what will be an approach for doing that so let us define it formally what are we trying to achieve so i am trying to search for a path by a path i mean what are the sequence of edit operations that i have to make for going from the start string to my final string ok so now i can define what is my initial state that is what is the word that i am trying to transform so in the previous example intention ok so this is my initial state then what are the various operators that i am allowed what various operators that i am allowed to use over my over any of the strings i am allowed to use insertion deletion or substitution these are my three opre operators and there is a one goal state that is the final string that i am trying to get so it will be execution the previous case and i want to minimize the path cost number of edits i want to find out what is the minimum number of operations or minimum path cost by which i can go from initial strings to final string ok so now if you think of it in a very naive manner what what will be an approach that you might try so i am starting with intention and i have to reach execution so one very naive method might be in intention and try out all possible edit operations until unless you reach execution ok so that is i shall int intention i see ok if i delete one character i can go go i can delete i i go to n intention similarly you might delete other characters ok you might insert one character in the beginning say e or you can insert in any of the places or you might try to substitute one character like e can be substitute by i can be substitute with e and that gives you another word and you might keep on trying all this operations until there is a point when you when you are at the goal state so this might be one a possible approach now what is even problem that you see where is approach ok so do not dont you think you might have to to travel a lot of paths that are not at all relevant for my problem ok why should i keep keep deleting i n t e n t i o n all together in one path when this will never give me execution ok so so so here i am trying to navigate all the possible edit operations to achieve the goal state ok but this is discuss me huge space ok we will try to work out one simple example that how many even if i if i try to find words with the addition one or two it might be the number of operation the the number of possibility might be huge so how can i make in optimal how can i optimise this ok so in this case what would also happen lot of paths might end up with the same state ok so i might end up with doing some insertion and another deletion that might end up in the same instead i was starting with or it might have a with one insertion deletion an another substitution so again this is unavoidable in that kind of approach but we will like to avoid it further do i really need to keep track of all of them i need only those paths that will come between intention to execution ok so so the idea would be i define some sort of a states and keep track what are the shortest paths to each state because ideally i want to find it what is the shortest distance between two strings so there is no reason that i should store all possible strings that all possible ah wage of arriving from one string to another that are having a higher distance ok because i want to keep the minimum distance path so so what is an approach that i will use so for that let us try to define it more formally so i have two strings x and y x is of length n and y is of length m and i am trying to find out the edit distance from x to n x to y so in general i can define some edit distance matrix so how will i define it so let us see my definition d i j where an element d i j denotes the edit distance between the first i characters of x and first j characters of y ok so how many operations i need to to make to go from i i characters of x to j characters of y ok so now as for this definition what will be the edit distance between x and y this will be simply d and m ok that means the n characters of x and m characters of y yes so now question is what kind of algorithm i should use for obtaining this particular the element of this matrix ok so there we will try to see this problem as a dynamic programming approach ok so so we will compute d n m in a tabular manner in general what do we do in dynamic programming so whenever we have to solve a problem we try to divided in such a manner that i first solve the smaller problems and try to use their solutions to solve the bigger problem so that i will i can avoid certain habitations in my computations ok so i will first start by solving d i j for small values of i n j and i will implemently use that to find out finally my d n m by using the the smaller values that i have already compute it ok so so this is the bottom of approach i first solve the very smalls of problems and then i use it to solve the bigger problems so i compute d i j for small i j and based on the smaller values that i have computed i will compute larger values of d i j ok and i keep on doing that until i get d n m so this will be our basic idea so now what we will need to see that how should i will be using the the smaller computations to get the value for the large amounts ok so i can define so here i am i can define my dynamic programming algorithm for finding out the edit distance between two strings ok so now so first we are doing the initialization so there we are saying d i zero is i and d zero j is j now does that make sense what is d i zero that is the distance between the i characters of x and zero characters of y now what will be the distance how many operations i have to make for going from i characters of x to zero characters of y and how can i do that the only possible way of doing it efficiently is i keep on deleting each of the characters so there will be i operations of deletions so the cost will be i similarly how we go from zero characters of x to j characters of y i can do j different insertion so thats why i can in initialized as d i zero is i and d zero j is j ok that is fine now in general how do i define d i j in terms of the previous the other sho short elements that i have already filled up ok so here are three by in which d i j might be filled so so suppose i am trying to find out the edit distance between x that is having right now i characters of x and y that is having j characters now the idea is that how go i compute d i j using the smaller values of i n j so that is how go use d i minus one j d i j minus one and d i minus one and j one so let us seen this example so i want to use d i minus one j so what is d i minus one j so this is suppose one character so this is my i minus one distance between x i minus one to y j and suppose we have already compute it that what is the minimum cost between x i minus one characters and y j characters now how do i use to find out what might be the minimum possible way of minimum possible edit distance between x and y j so for the i characters in x i can do a deletion i go to x i minus one and then i use the distance between x i minus one y j ok so how can i write the distance i can say that same distance that much would be d i minus one j ok plus one because i deleted one character from x is that clear in x i i delete one character i i went to x i minus one and i have already completed distance between x i minus one and y j ok so that is one for deletion and and this cost we already have similarly how do you use the use d i j minus one same idea so here i have x and y x is i y as j and suppose i have already computed i j minus one so how will i compute the distance between i and j i is the same distance that i computed between i and j minus one plus i inserted the jth character ok so this you can think of it a has insertion so distance will be i j minus one and one ok and what might be the the third possibility third possibility would be that i know what is the distance between i minus one j minus one and i am seeing whether i am substituting i with j ok so so there might be two ways if these characters are the same that means i am not having any cost but if there are different characters i will have a cost corresponding to the substitution so d i minus one j minus one plus two if the characters are not same and zero if they are same ok so there are three ways in which i can i can write d i j it can by the d i minus one j j plus one d i j minus one plus one or d i minus one j minus one plus two if the characters are different or zero if the characters are the same so there are three different ways i can define these cost now the cost we are only store in the minimum cost i will see what is the minimum of all three cost and thats what i will storage d i j and that i keep on doing this until i arrive it d n m so that is the simple dynamic programming approach for solving this ok so let us see once one example now so same example intention and execution ok so now so we have already filled up some entries here now can you relate to this what are what is this entry this is my d one zero so initialization we saw that d one zero will be simply one because that mean i can simply delete i can delete this character and i a achieve arrive at the final sub history it starting from i how do i go to null i delete i so this is one similarly this will be two i can delete i and n one at a time this will be three i n t and all so on similarly why this is one from null to e that means i am inserting one character ok null two e x i am inserting two characters so this will one two and so on so that explains all these initial levenshtein distance in this step now my my problem is how do i fill up the other this stable so for example how i fill this this particular ok so now how did we define my dynamic programming approach i said i will filled d i j based on d i minus one j d i j minus one and d i minus one j and j minus one now in this case what is d i minus one j suppose i want to fill this element this my d i j what is d i minus one j this is my my i minus one j what is my d i j minus one this is my i j minus one and what is my i minus one j minus one this is my i minus one j minus one now what will be the cost here it will be minimum of all this three operations so let us find out for individual d i minus one j is one plus one so this gives me two d i j minus one cost between null and i am sorry i think i i i wrote it incorrectly it should be d i j minus one and there should be the d i minus one j ok fine so what is d i minus one j that is from null to e ok what is the cost one plus one that will be two d i j minus one is i to null that is one plus one this will again give me two and d i minus one j minus one is j zero yes plus two if the if the two characters are not the same so here the two characters i and e there are not the same so this will be two so that is i can go from any of these paths and i have a cost of two so minimum will again we two so i enter here ok so now suppose you want to use that to find out the value here so now one think we can see i need three different entries this this and this ok so what will be the cost minimum of three three three again this will be three so like that i will keep on filling up all the table until i arrive at this element that is my d n m ok so in general there might be more than one ways of arriving at the minimum cost so we will see how do we store that but right now we can just put that cost as it is so where fill up this complete matrix this is what i will get ok and you see the distance between intention execution in this case is eight ok so but but you also see in this slide that for certain strings the edit distance might go up to twelve ok that is possible but finally the edit distance between intention execution comes up to be eight ok so this up this approach gives me very very efficiently what is the edit distance between one string and another string and we know how to use this now so there is one further thing that we can do with this algorithm so that is again depending on my algorithm my particular task that is about computing alignments ok so for some applications we just want to know what is the edit distance between two strings but for other applications you might also want to find out what are all the places where the edit took place so what is the alignment remember the way we did the case of intention versus execution we found out what are the actual places where where insertion deletion substitution are taking place so this is what i mean by alignment which parts are line to the other part in the string so now the question is can i modify the same algorithm to also find out what will be the various alignments in the string ok an you will see it is very very easy by using the previous algorithm that we have seen ok for some application we might need to align characters of the two strings to each other now we do this by keeping a sort of backtrace so what do you mean by backtrace so whenever i am filling out the value of d i j i can come of from either d i minus one j d i j minus one or d i minus one j minus one so whichever gives me the minimum cost i will put a pointer that i came from either form left from bottom or diagonal diagonal element ok so whenever i i i am at d n m i will again start doing a backtrace from there which element i came here from and i keep on doing it from started from there until i arrive at the null characters ok so every time we enter a cell we remember where we came from and when we reach the end we trace back the path from the upper right corner to read read all the alignment ok so let us see how we will do that in this case so suppose i was filling up this element and i know i can come from either here or here or here all three are equally likely so i will put all i might put all three points but suppose when i was here the the best possible we was this one so i should have come from the diagonal to this element so this is what i will store similarly here i will store another back point and so on so now once my edit operation is over i all all you have these back point is each and every cell i start from d n m and keep on following by back point so suppose i follow this one i reach this cell again i follow point i reach this cell this one and so on until i reach the null characters and that will give me the alignment of two strings ok so here so you will have alignment starting from d n m so we will see from here i can go to the this element this element this element now when i am here it quick have come from either of the three elements so you might have some sort of preference you might say ok i whenever there equal to equal possibility among all three i will always diagonal ok this you might say so you come to this element then you go to left then again you go down based on preference down based on preference down based on preference and then thats where you get your alignment so this is the this is some way you you can compute which characters in intention are align to which character in executions ok so simple idea whenever so you can say these are deletion insertion and substitution so whichever gives you the minimum cost you will add that pointer if all three are giving you the same cost you might have all the three point ok ok so in general suppose i start with a with a word x zero to x n so zero means null x n is the complete word x and i have the output string y zero to y m so if i see this matrix of size n cross m so every possible ah path from zero to zero zero to m n is a possible alignment ok so what i am trying to find out which path gives me the minimum possible edit distance ok and this in in as per dynamic programming approach and optimal alignment should be composed optimal sub alignments so that means whenever i am going from i to j i can use always the optimal sub align alignment would be i minus one j and so on ok so thats how this problem algorithm is designed ok so if you do the victories you can find out from the intention you go to executions and what are all the places where you did insertion deletion and substitutions ok and which words you did not have to change at all ok now what is the complexity of this algorithm so lets talk about the time complexity how much time we took so you see you have to fill all the n cross m entries of the matrix so there are n cross m different ah think you have to do and for each entry you need a question number of operation you will find out minimum of three different distances so there are n cross m times some constant so the time complexity can be simply order of n m ok yes what would the space complicity again the space complexity also the same you are using only n cross m different element that must the space that you need you are not using any other space remember for each element you are using some other elements from the same matrix so you not an any edit distance space so again a space complexity is n cross m now what about the backtrace so that is i am i am at d n m and i want to find backtrace the worst case can be i find i have to go through all the n elements in my column n elements sorry n elements in my top and m elements in my ah first column ok so in the worst case i might have to do n plus m different operations so this complexity is again n plus m ok so you will see this is very very efficient in compare to the approach that fever the naive approach that you have seen earlier you start with the input strings try out all possibility this will be become explanation very very soon so fine so this for this first lecture for for this week and in the next lecture we will start talking about certain variation of edit distance ok why why do i actually why should i even think of some variations and how do we use that for finding edit distance ok